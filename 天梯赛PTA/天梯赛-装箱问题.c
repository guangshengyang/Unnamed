/*
假设有N项物品，大小分别为s
​1
​​ 、s
​2
​​ 、…、s
​i
​​ 、…、s
​N
​​ ，其中s
​i
​​ 为满足1≤s
​i
​​ ≤100的整数。要把这些物品装入到容量为100的一批箱子（序号1-N）中。装箱方法是：对每项物品, 顺序扫描箱子，把该物品放入足以能够容下它的第一个箱子中。请写一个程序模拟这种装箱过程，并输出每个物品所在的箱子序号，以及放置全部物品所需的箱子数目。

输入格式：
输入第一行给出物品个数N（≤1000）；第二行给出N个正整数s
​i
​​ （1≤s
​i
​​ ≤100，表示第i项物品的大小）。

输出格式：
按照输入顺序输出每个物品的大小及其所在的箱子序号，每个物品占1行，最后一行输出所需的箱子数目。

输入样例：
8
60 70 80 90 30 40 10 20

      
    
输出样例：
60 1
70 2
80 3
90 4
30 1
40 5
10 1
20 2
5
*/

#include <stdio.h>

int main(void)
{
    int n, i, j;
    int max = 0; //index箱子标号最大那个，暂时初始化为0
    static int a[1000], , b[1000] ，index[1000];
    scanf("%d", &n);

    for (i = 0; i < n; i++)
    {
        scanf("%d", &a[i]);
        b[i] = a[i]; //备份一份数组初值
    }

    for (i = 0; i < n; i++)
    {
        for (j = 0; j < i; j++) //内层循环从头开始找，找能装下的
        {
            if (a[i] + a[j] <= 100) //装物品的箱子容量最多只有100
            {
                a[j] += a[i]; //将a[i]值加到a[j]上去，找到后排除之前位置上箱子思想
                a[i] = 0;     //a[j]更新后，a[i]也要更新为零
                index[i] = j; //index为存储箱子编号的数组
                break;        // 找到符合条件的就跳出循环
            }
            else
                index[i] = i;
        }
    }
    for (i = 0; i < n; i++)
    {
        if (index[i] > index[max])
            max = i; //找到index[]值最大的那个，就是箱子数
    }

    for (i = 0; i < n; i++)
        printf("%d %d\n", b[i], index[i] + 1); //加一因为数组技术是从0开始，而不是1

    printf("%d", index[max] + 1); //加一因为数组技术是从0开始，而不是1

    return 0;
}
